/* Group.c generated by valac 0.34.4, the Vala compiler
 * generated from Group.gs, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gee.h>


#define ENTITAS_TYPE_GROUP (entitas_group_get_type ())
#define ENTITAS_GROUP(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ENTITAS_TYPE_GROUP, EntitasGroup))
#define ENTITAS_GROUP_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ENTITAS_TYPE_GROUP, EntitasGroupClass))
#define ENTITAS_IS_GROUP(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ENTITAS_TYPE_GROUP))
#define ENTITAS_IS_GROUP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ENTITAS_TYPE_GROUP))
#define ENTITAS_GROUP_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ENTITAS_TYPE_GROUP, EntitasGroupClass))

typedef struct _EntitasGroup EntitasGroup;
typedef struct _EntitasGroupClass EntitasGroupClass;
typedef struct _EntitasGroupPrivate EntitasGroupPrivate;

#define ENTITAS_TYPE_GROUP_CHANGED (entitas_group_changed_get_type ())
#define ENTITAS_GROUP_CHANGED(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ENTITAS_TYPE_GROUP_CHANGED, EntitasGroupChanged))
#define ENTITAS_GROUP_CHANGED_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ENTITAS_TYPE_GROUP_CHANGED, EntitasGroupChangedClass))
#define ENTITAS_IS_GROUP_CHANGED(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ENTITAS_TYPE_GROUP_CHANGED))
#define ENTITAS_IS_GROUP_CHANGED_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ENTITAS_TYPE_GROUP_CHANGED))
#define ENTITAS_GROUP_CHANGED_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ENTITAS_TYPE_GROUP_CHANGED, EntitasGroupChangedClass))

typedef struct _EntitasGroupChanged EntitasGroupChanged;
typedef struct _EntitasGroupChangedClass EntitasGroupChangedClass;

#define ENTITAS_TYPE_GROUP_UPDATED (entitas_group_updated_get_type ())
#define ENTITAS_GROUP_UPDATED(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ENTITAS_TYPE_GROUP_UPDATED, EntitasGroupUpdated))
#define ENTITAS_GROUP_UPDATED_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ENTITAS_TYPE_GROUP_UPDATED, EntitasGroupUpdatedClass))
#define ENTITAS_IS_GROUP_UPDATED(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ENTITAS_TYPE_GROUP_UPDATED))
#define ENTITAS_IS_GROUP_UPDATED_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ENTITAS_TYPE_GROUP_UPDATED))
#define ENTITAS_GROUP_UPDATED_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ENTITAS_TYPE_GROUP_UPDATED, EntitasGroupUpdatedClass))

typedef struct _EntitasGroupUpdated EntitasGroupUpdated;
typedef struct _EntitasGroupUpdatedClass EntitasGroupUpdatedClass;

#define ENTITAS_TYPE_IMATCHER (entitas_imatcher_get_type ())
#define ENTITAS_IMATCHER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ENTITAS_TYPE_IMATCHER, EntitasIMatcher))
#define ENTITAS_IS_IMATCHER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ENTITAS_TYPE_IMATCHER))
#define ENTITAS_IMATCHER_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), ENTITAS_TYPE_IMATCHER, EntitasIMatcherIface))

typedef struct _EntitasIMatcher EntitasIMatcher;
typedef struct _EntitasIMatcherIface EntitasIMatcherIface;

#define ENTITAS_TYPE_ENTITY (entitas_entity_get_type ())
#define ENTITAS_ENTITY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ENTITAS_TYPE_ENTITY, EntitasEntity))
#define ENTITAS_ENTITY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ENTITAS_TYPE_ENTITY, EntitasEntityClass))
#define ENTITAS_IS_ENTITY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ENTITAS_TYPE_ENTITY))
#define ENTITAS_IS_ENTITY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ENTITAS_TYPE_ENTITY))
#define ENTITAS_ENTITY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ENTITAS_TYPE_ENTITY, EntitasEntityClass))

typedef struct _EntitasEntity EntitasEntity;
typedef struct _EntitasEntityClass EntitasEntityClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define ENTITAS_TYPE_ICOMPONENT (entitas_icomponent_get_type ())
#define ENTITAS_ICOMPONENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ENTITAS_TYPE_ICOMPONENT, EntitasIComponent))
#define ENTITAS_IS_ICOMPONENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ENTITAS_TYPE_ICOMPONENT))
#define ENTITAS_ICOMPONENT_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), ENTITAS_TYPE_ICOMPONENT, EntitasIComponentIface))

typedef struct _EntitasIComponent EntitasIComponent;
typedef struct _EntitasIComponentIface EntitasIComponentIface;
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

struct _EntitasGroup {
	GObject parent_instance;
	EntitasGroupPrivate * priv;
};

struct _EntitasGroupClass {
	GObjectClass parent_class;
};

struct _EntitasIMatcherIface {
	GTypeInterface parent_iface;
	gboolean (*matches) (EntitasIMatcher* self, EntitasEntity* entity);
	gchar* (*toString) (EntitasIMatcher* self);
	const gchar* (*get_id) (EntitasIMatcher* self);
	gint* (*get_indices) (EntitasIMatcher* self, int* result_length1);
};

struct _EntitasGroupPrivate {
	EntitasGroupChanged* _onEntityAdded;
	EntitasGroupChanged* _onEntityRemoved;
	EntitasGroupUpdated* _onEntityUpdated;
	EntitasIMatcher* _matcher;
	GeeHashMap* _entities;
	EntitasEntity** _entitiesCache;
	gint _entitiesCache_length1;
	gint __entitiesCache_size_;
	EntitasEntity* _singleEntityCache;
	gchar* _toStringCache;
};

typedef enum  {
	ENTITAS_ECS_EXCEPTION_EntityIsNotEnabled,
	ENTITAS_ECS_EXCEPTION_EntityAlreadyHasComponent,
	ENTITAS_ECS_EXCEPTION_EntityDoesNotHaveComponent,
	ENTITAS_ECS_EXCEPTION_EntityIsAlreadyReleased,
	ENTITAS_ECS_EXCEPTION_SingleEntity,
	ENTITAS_ECS_EXCEPTION_Matcher,
	ENTITAS_ECS_EXCEPTION_WorldDoesNotContainEntity
} EntitasEcsException;
#define ENTITAS_ECS_EXCEPTION entitas_ecs_exception_quark ()
struct _EntitasIComponentIface {
	GTypeInterface parent_iface;
};


static gpointer entitas_group_parent_class = NULL;

GType entitas_group_get_type (void) G_GNUC_CONST;
GType entitas_group_changed_get_type (void) G_GNUC_CONST;
GType entitas_group_updated_get_type (void) G_GNUC_CONST;
GType entitas_entity_get_type (void) G_GNUC_CONST;
GType entitas_imatcher_get_type (void) G_GNUC_CONST;
#define ENTITAS_GROUP_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), ENTITAS_TYPE_GROUP, EntitasGroupPrivate))
enum  {
	ENTITAS_GROUP_DUMMY_PROPERTY,
	ENTITAS_GROUP_ON_ENTITY_ADDED,
	ENTITAS_GROUP_ON_ENTITY_REMOVED,
	ENTITAS_GROUP_ON_ENTITY_UPDATED,
	ENTITAS_GROUP_COUNT,
	ENTITAS_GROUP_MATCHER
};
EntitasGroup* entitas_group_new (EntitasIMatcher* matcher);
EntitasGroup* entitas_group_construct (GType object_type, EntitasIMatcher* matcher);
EntitasGroupChanged* entitas_group_changed_new (void);
EntitasGroupChanged* entitas_group_changed_construct (GType object_type);
EntitasGroupUpdated* entitas_group_updated_new (void);
EntitasGroupUpdated* entitas_group_updated_construct (GType object_type);
GQuark entitas_ecs_exception_quark (void);
void entitas_group_handleEntitySilently (EntitasGroup* self, EntitasEntity* entity, GError** error);
gboolean entitas_imatcher_matches (EntitasIMatcher* self, EntitasEntity* entity);
void entitas_group_addEntitySilently (EntitasGroup* self, EntitasEntity* entity);
void entitas_group_removeEntitySilently (EntitasGroup* self, EntitasEntity* entity, GError** error);
GType entitas_icomponent_get_type (void) G_GNUC_CONST;
void entitas_group_handleEntity (EntitasGroup* self, EntitasEntity* entity, gint index, EntitasIComponent* component, GError** error);
void entitas_group_addEntity (EntitasGroup* self, EntitasEntity* entity, gint index, EntitasIComponent* component);
void entitas_group_removeEntity (EntitasGroup* self, EntitasEntity* entity, gint index, EntitasIComponent* component, GError** error);
void entitas_group_updateEntity (EntitasGroup* self, EntitasEntity* entity, gint index, EntitasIComponent* previousComponent, EntitasIComponent* newComponent);
const gchar* entitas_entity_get_id (EntitasEntity* self);
void entitas_group_changed_dispatch (EntitasGroupChanged* self, EntitasGroup* g, EntitasEntity* e, gint i, EntitasIComponent* c);
void entitas_group_updated_dispatch (EntitasGroupUpdated* self, EntitasGroup* g, EntitasEntity* e, gint i, EntitasIComponent* c, EntitasIComponent* u);
EntitasEntity* entitas_entity_addRef (EntitasEntity* self);
void entitas_entity_release (EntitasEntity* self, GError** error);
gboolean entitas_group_containsEntity (EntitasGroup* self, EntitasEntity* entity);
EntitasEntity** entitas_group_getEntities (EntitasGroup* self, int* result_length1);
static EntitasEntity** _vala_array_dup5 (EntitasEntity** self, int length);
EntitasEntity* entitas_group_getSingleEntity (EntitasGroup* self, GError** error);
gchar* entitas_imatcher_toString (EntitasIMatcher* self);
gchar* entitas_group_toString (EntitasGroup* self);
gint* entitas_imatcher_get_indices (EntitasIMatcher* self, int* result_length1);
gchar** entitas_world_get_components (int* result_length1);
static void _vala_array_add3 (gchar*** array, int* length, int* size, gchar* value);
EntitasGroupChanged* entitas_group_get_onEntityAdded (EntitasGroup* self);
EntitasGroupChanged* entitas_group_get_onEntityRemoved (EntitasGroup* self);
EntitasGroupUpdated* entitas_group_get_onEntityUpdated (EntitasGroup* self);
gint entitas_group_get_count (EntitasGroup* self);
EntitasIMatcher* entitas_group_get_matcher (EntitasGroup* self);
static void entitas_group_finalize (GObject* obj);
static void _vala_entitas_group_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


EntitasGroup* entitas_group_construct (GType object_type, EntitasIMatcher* matcher) {
	EntitasGroup * self = NULL;
	GeeHashMap* _tmp0_ = NULL;
	EntitasEntity** _tmp1_ = NULL;
	EntitasGroupChanged* _tmp2_ = NULL;
	EntitasGroupChanged* _tmp3_ = NULL;
	EntitasGroupUpdated* _tmp4_ = NULL;
	EntitasIMatcher* _tmp5_ = NULL;
	EntitasIMatcher* _tmp6_ = NULL;
	g_return_val_if_fail (matcher != NULL, NULL);
	self = (EntitasGroup*) g_object_new (object_type, NULL);
	_tmp0_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, ENTITAS_TYPE_ENTITY, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	_g_object_unref0 (self->priv->_entities);
	self->priv->_entities = _tmp0_;
	_tmp1_ = g_new0 (EntitasEntity*, 0 + 1);
	self->priv->_entitiesCache = (_vala_array_free (self->priv->_entitiesCache, self->priv->_entitiesCache_length1, (GDestroyNotify) g_object_unref), NULL);
	self->priv->_entitiesCache = _tmp1_;
	self->priv->_entitiesCache_length1 = 0;
	self->priv->__entitiesCache_size_ = self->priv->_entitiesCache_length1;
	_tmp2_ = entitas_group_changed_new ();
	_g_object_unref0 (self->priv->_onEntityAdded);
	self->priv->_onEntityAdded = _tmp2_;
	_tmp3_ = entitas_group_changed_new ();
	_g_object_unref0 (self->priv->_onEntityRemoved);
	self->priv->_onEntityRemoved = _tmp3_;
	_tmp4_ = entitas_group_updated_new ();
	_g_object_unref0 (self->priv->_onEntityUpdated);
	self->priv->_onEntityUpdated = _tmp4_;
	_tmp5_ = matcher;
	_tmp6_ = _g_object_ref0 (_tmp5_);
	_g_object_unref0 (self->priv->_matcher);
	self->priv->_matcher = _tmp6_;
	return self;
}


EntitasGroup* entitas_group_new (EntitasIMatcher* matcher) {
	return entitas_group_construct (ENTITAS_TYPE_GROUP, matcher);
}


/**
         * Handle adding and removing component from the entity without raising events
         * @param entity
         */
void entitas_group_handleEntitySilently (EntitasGroup* self, EntitasEntity* entity, GError** error) {
	EntitasIMatcher* _tmp0_ = NULL;
	EntitasEntity* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (entity != NULL);
	_tmp0_ = self->priv->_matcher;
	_tmp1_ = entity;
	_tmp2_ = entitas_imatcher_matches (_tmp0_, _tmp1_);
	if (_tmp2_) {
		EntitasEntity* _tmp3_ = NULL;
		_tmp3_ = entity;
		entitas_group_addEntitySilently (self, _tmp3_);
	} else {
		EntitasEntity* _tmp4_ = NULL;
		_tmp4_ = entity;
		entitas_group_removeEntitySilently (self, _tmp4_, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == ENTITAS_ECS_EXCEPTION) {
				g_propagate_error (error, _inner_error_);
				return;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
	}
}


/**
         * Handle adding and removing component from the entity and raisieevents
         * @param entity
         * @param index
         * @param component
         */
void entitas_group_handleEntity (EntitasGroup* self, EntitasEntity* entity, gint index, EntitasIComponent* component, GError** error) {
	EntitasIMatcher* _tmp0_ = NULL;
	EntitasEntity* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (entity != NULL);
	g_return_if_fail (component != NULL);
	_tmp0_ = self->priv->_matcher;
	_tmp1_ = entity;
	_tmp2_ = entitas_imatcher_matches (_tmp0_, _tmp1_);
	if (_tmp2_) {
		EntitasEntity* _tmp3_ = NULL;
		gint _tmp4_ = 0;
		EntitasIComponent* _tmp5_ = NULL;
		_tmp3_ = entity;
		_tmp4_ = index;
		_tmp5_ = component;
		entitas_group_addEntity (self, _tmp3_, _tmp4_, _tmp5_);
	} else {
		EntitasEntity* _tmp6_ = NULL;
		gint _tmp7_ = 0;
		EntitasIComponent* _tmp8_ = NULL;
		_tmp6_ = entity;
		_tmp7_ = index;
		_tmp8_ = component;
		entitas_group_removeEntity (self, _tmp6_, _tmp7_, _tmp8_, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == ENTITAS_ECS_EXCEPTION) {
				g_propagate_error (error, _inner_error_);
				return;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
	}
}


/**
         * Update entity and raise events
         * @param entity
         * @param index
         * @param previousComponent
         * @param newComponent
         */
void entitas_group_updateEntity (EntitasGroup* self, EntitasEntity* entity, gint index, EntitasIComponent* previousComponent, EntitasIComponent* newComponent) {
	GeeHashMap* _tmp0_ = NULL;
	EntitasEntity* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (entity != NULL);
	g_return_if_fail (previousComponent != NULL);
	g_return_if_fail (newComponent != NULL);
	_tmp0_ = self->priv->_entities;
	_tmp1_ = entity;
	_tmp2_ = entitas_entity_get_id (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = gee_abstract_map_has_key ((GeeAbstractMap*) _tmp0_, _tmp3_);
	if (_tmp4_) {
		EntitasGroupChanged* _tmp5_ = NULL;
		EntitasEntity* _tmp6_ = NULL;
		gint _tmp7_ = 0;
		EntitasIComponent* _tmp8_ = NULL;
		EntitasGroupChanged* _tmp9_ = NULL;
		EntitasEntity* _tmp10_ = NULL;
		gint _tmp11_ = 0;
		EntitasIComponent* _tmp12_ = NULL;
		EntitasGroupUpdated* _tmp13_ = NULL;
		EntitasEntity* _tmp14_ = NULL;
		gint _tmp15_ = 0;
		EntitasIComponent* _tmp16_ = NULL;
		EntitasIComponent* _tmp17_ = NULL;
		_tmp5_ = self->priv->_onEntityRemoved;
		_tmp6_ = entity;
		_tmp7_ = index;
		_tmp8_ = previousComponent;
		entitas_group_changed_dispatch (_tmp5_, self, _tmp6_, _tmp7_, _tmp8_);
		_tmp9_ = self->priv->_onEntityAdded;
		_tmp10_ = entity;
		_tmp11_ = index;
		_tmp12_ = newComponent;
		entitas_group_changed_dispatch (_tmp9_, self, _tmp10_, _tmp11_, _tmp12_);
		_tmp13_ = self->priv->_onEntityUpdated;
		_tmp14_ = entity;
		_tmp15_ = index;
		_tmp16_ = previousComponent;
		_tmp17_ = newComponent;
		entitas_group_updated_dispatch (_tmp13_, self, _tmp14_, _tmp15_, _tmp16_, _tmp17_);
	}
}


/**
         * Add entity without raising events
         * @param entity
         */
void entitas_group_addEntitySilently (EntitasGroup* self, EntitasEntity* entity) {
	GeeHashMap* _tmp0_ = NULL;
	EntitasEntity* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (entity != NULL);
	_tmp0_ = self->priv->_entities;
	_tmp1_ = entity;
	_tmp2_ = entitas_entity_get_id (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = gee_abstract_map_has_key ((GeeAbstractMap*) _tmp0_, _tmp3_);
	if (!_tmp4_) {
		GeeHashMap* _tmp5_ = NULL;
		EntitasEntity* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		const gchar* _tmp8_ = NULL;
		EntitasEntity* _tmp9_ = NULL;
		EntitasEntity* _tmp10_ = NULL;
		EntitasEntity* _tmp11_ = NULL;
		EntitasEntity* _tmp12_ = NULL;
		_tmp5_ = self->priv->_entities;
		_tmp6_ = entity;
		_tmp7_ = entitas_entity_get_id (_tmp6_);
		_tmp8_ = _tmp7_;
		_tmp9_ = entity;
		gee_abstract_map_set ((GeeAbstractMap*) _tmp5_, _tmp8_, _tmp9_);
		self->priv->_entitiesCache = (_vala_array_free (self->priv->_entitiesCache, self->priv->_entitiesCache_length1, (GDestroyNotify) g_object_unref), NULL);
		self->priv->_entitiesCache = NULL;
		self->priv->_entitiesCache_length1 = 0;
		self->priv->__entitiesCache_size_ = self->priv->_entitiesCache_length1;
		_g_object_unref0 (self->priv->_singleEntityCache);
		self->priv->_singleEntityCache = NULL;
		_tmp10_ = entity;
		_tmp11_ = entitas_entity_addRef (_tmp10_);
		_tmp12_ = _tmp11_;
		_g_object_unref0 (_tmp12_);
	}
}


/**
         * Add entity and raise events
         * @param entity
         * @param index
         * @param component
         */
void entitas_group_addEntity (EntitasGroup* self, EntitasEntity* entity, gint index, EntitasIComponent* component) {
	GeeHashMap* _tmp0_ = NULL;
	EntitasEntity* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (entity != NULL);
	g_return_if_fail (component != NULL);
	_tmp0_ = self->priv->_entities;
	_tmp1_ = entity;
	_tmp2_ = entitas_entity_get_id (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = gee_abstract_map_has_key ((GeeAbstractMap*) _tmp0_, _tmp3_);
	if (!_tmp4_) {
		GeeHashMap* _tmp5_ = NULL;
		EntitasEntity* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		const gchar* _tmp8_ = NULL;
		EntitasEntity* _tmp9_ = NULL;
		EntitasEntity* _tmp10_ = NULL;
		EntitasEntity* _tmp11_ = NULL;
		EntitasEntity* _tmp12_ = NULL;
		EntitasGroupChanged* _tmp13_ = NULL;
		EntitasEntity* _tmp14_ = NULL;
		gint _tmp15_ = 0;
		EntitasIComponent* _tmp16_ = NULL;
		_tmp5_ = self->priv->_entities;
		_tmp6_ = entity;
		_tmp7_ = entitas_entity_get_id (_tmp6_);
		_tmp8_ = _tmp7_;
		_tmp9_ = entity;
		gee_abstract_map_set ((GeeAbstractMap*) _tmp5_, _tmp8_, _tmp9_);
		self->priv->_entitiesCache = (_vala_array_free (self->priv->_entitiesCache, self->priv->_entitiesCache_length1, (GDestroyNotify) g_object_unref), NULL);
		self->priv->_entitiesCache = NULL;
		self->priv->_entitiesCache_length1 = 0;
		self->priv->__entitiesCache_size_ = self->priv->_entitiesCache_length1;
		_g_object_unref0 (self->priv->_singleEntityCache);
		self->priv->_singleEntityCache = NULL;
		_tmp10_ = entity;
		_tmp11_ = entitas_entity_addRef (_tmp10_);
		_tmp12_ = _tmp11_;
		_g_object_unref0 (_tmp12_);
		_tmp13_ = self->priv->_onEntityAdded;
		_tmp14_ = entity;
		_tmp15_ = index;
		_tmp16_ = component;
		entitas_group_changed_dispatch (_tmp13_, self, _tmp14_, _tmp15_, _tmp16_);
	}
}


/**
         * Remove entity without raising events
         * @param entity
         */
void entitas_group_removeEntitySilently (EntitasGroup* self, EntitasEntity* entity, GError** error) {
	GeeHashMap* _tmp0_ = NULL;
	EntitasEntity* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (entity != NULL);
	_tmp0_ = self->priv->_entities;
	_tmp1_ = entity;
	_tmp2_ = entitas_entity_get_id (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = gee_abstract_map_has_key ((GeeAbstractMap*) _tmp0_, _tmp3_);
	if (_tmp4_) {
		GeeHashMap* _tmp5_ = NULL;
		EntitasEntity* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		const gchar* _tmp8_ = NULL;
		EntitasEntity* _tmp9_ = NULL;
		_tmp5_ = self->priv->_entities;
		_tmp6_ = entity;
		_tmp7_ = entitas_entity_get_id (_tmp6_);
		_tmp8_ = _tmp7_;
		gee_abstract_map_unset ((GeeAbstractMap*) _tmp5_, _tmp8_, NULL);
		self->priv->_entitiesCache = (_vala_array_free (self->priv->_entitiesCache, self->priv->_entitiesCache_length1, (GDestroyNotify) g_object_unref), NULL);
		self->priv->_entitiesCache = NULL;
		self->priv->_entitiesCache_length1 = 0;
		self->priv->__entitiesCache_size_ = self->priv->_entitiesCache_length1;
		_g_object_unref0 (self->priv->_singleEntityCache);
		self->priv->_singleEntityCache = NULL;
		_tmp9_ = entity;
		entitas_entity_release (_tmp9_, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == ENTITAS_ECS_EXCEPTION) {
				g_propagate_error (error, _inner_error_);
				return;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
	}
}


/**
         * Remove entity and raise events
         * @param entity
         * @param index
         * @param component
         */
void entitas_group_removeEntity (EntitasGroup* self, EntitasEntity* entity, gint index, EntitasIComponent* component, GError** error) {
	GeeHashMap* _tmp0_ = NULL;
	EntitasEntity* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (entity != NULL);
	g_return_if_fail (component != NULL);
	_tmp0_ = self->priv->_entities;
	_tmp1_ = entity;
	_tmp2_ = entitas_entity_get_id (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = gee_abstract_map_has_key ((GeeAbstractMap*) _tmp0_, _tmp3_);
	if (_tmp4_) {
		GeeHashMap* _tmp5_ = NULL;
		EntitasEntity* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		const gchar* _tmp8_ = NULL;
		EntitasGroupChanged* _tmp9_ = NULL;
		EntitasEntity* _tmp10_ = NULL;
		gint _tmp11_ = 0;
		EntitasIComponent* _tmp12_ = NULL;
		EntitasEntity* _tmp13_ = NULL;
		_tmp5_ = self->priv->_entities;
		_tmp6_ = entity;
		_tmp7_ = entitas_entity_get_id (_tmp6_);
		_tmp8_ = _tmp7_;
		gee_abstract_map_unset ((GeeAbstractMap*) _tmp5_, _tmp8_, NULL);
		self->priv->_entitiesCache = (_vala_array_free (self->priv->_entitiesCache, self->priv->_entitiesCache_length1, (GDestroyNotify) g_object_unref), NULL);
		self->priv->_entitiesCache = NULL;
		self->priv->_entitiesCache_length1 = 0;
		self->priv->__entitiesCache_size_ = self->priv->_entitiesCache_length1;
		_g_object_unref0 (self->priv->_singleEntityCache);
		self->priv->_singleEntityCache = NULL;
		_tmp9_ = self->priv->_onEntityRemoved;
		_tmp10_ = entity;
		_tmp11_ = index;
		_tmp12_ = component;
		entitas_group_changed_dispatch (_tmp9_, self, _tmp10_, _tmp11_, _tmp12_);
		_tmp13_ = entity;
		entitas_entity_release (_tmp13_, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == ENTITAS_ECS_EXCEPTION) {
				g_propagate_error (error, _inner_error_);
				return;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
	}
}


/**
         * Check if group has this entity
         *
         * @param entity
         * @returns boolean
         */
gboolean entitas_group_containsEntity (EntitasGroup* self, EntitasEntity* entity) {
	gboolean result = FALSE;
	GeeHashMap* _tmp0_ = NULL;
	EntitasEntity* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (entity != NULL, FALSE);
	_tmp0_ = self->priv->_entities;
	_tmp1_ = entity;
	_tmp2_ = entitas_entity_get_id (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = gee_abstract_map_has_key ((GeeAbstractMap*) _tmp0_, _tmp3_);
	result = _tmp4_;
	return result;
}


/**
         * Get a list of the entities in this group
         *
         * @returns Array<entitas.Entity>
         */
static EntitasEntity** _vala_array_dup5 (EntitasEntity** self, int length) {
	EntitasEntity** result;
	int i;
	result = g_new0 (EntitasEntity*, length + 1);
	for (i = 0; i < length; i++) {
		EntitasEntity* _tmp0_ = NULL;
		_tmp0_ = _g_object_ref0 (self[i]);
		result[i] = _tmp0_;
	}
	return result;
}


EntitasEntity** entitas_group_getEntities (EntitasGroup* self, int* result_length1) {
	EntitasEntity** result = NULL;
	EntitasEntity** _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	EntitasEntity** _tmp23_ = NULL;
	gint _tmp23__length1 = 0;
	EntitasEntity** _tmp24_ = NULL;
	gint _tmp24__length1 = 0;
	EntitasEntity** _tmp25_ = NULL;
	gint _tmp25__length1 = 0;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_entitiesCache;
	_tmp0__length1 = self->priv->_entitiesCache_length1;
	if (_tmp0__length1 == 0) {
		GeeHashMap* _tmp1_ = NULL;
		GeeCollection* _tmp2_ = NULL;
		GeeCollection* _tmp3_ = NULL;
		GeeCollection* _tmp4_ = NULL;
		gint _tmp5_ = 0;
		gint _tmp6_ = 0;
		EntitasEntity** _tmp7_ = NULL;
		gint i = 0;
		_tmp1_ = self->priv->_entities;
		_tmp2_ = gee_abstract_map_get_values ((GeeMap*) _tmp1_);
		_tmp3_ = _tmp2_;
		_tmp4_ = _tmp3_;
		_tmp5_ = gee_collection_get_size (_tmp4_);
		_tmp6_ = _tmp5_;
		_tmp7_ = g_new0 (EntitasEntity*, _tmp6_ + 1);
		self->priv->_entitiesCache = (_vala_array_free (self->priv->_entitiesCache, self->priv->_entitiesCache_length1, (GDestroyNotify) g_object_unref), NULL);
		self->priv->_entitiesCache = _tmp7_;
		self->priv->_entitiesCache_length1 = _tmp6_;
		self->priv->__entitiesCache_size_ = self->priv->_entitiesCache_length1;
		_g_object_unref0 (_tmp4_);
		i = 0;
		{
			GeeIterator* _e_it = NULL;
			GeeHashMap* _tmp8_ = NULL;
			GeeCollection* _tmp9_ = NULL;
			GeeCollection* _tmp10_ = NULL;
			GeeCollection* _tmp11_ = NULL;
			GeeIterator* _tmp12_ = NULL;
			GeeIterator* _tmp13_ = NULL;
			_tmp8_ = self->priv->_entities;
			_tmp9_ = gee_abstract_map_get_values ((GeeMap*) _tmp8_);
			_tmp10_ = _tmp9_;
			_tmp11_ = _tmp10_;
			_tmp12_ = gee_iterable_iterator ((GeeIterable*) _tmp11_);
			_tmp13_ = _tmp12_;
			_g_object_unref0 (_tmp11_);
			_e_it = _tmp13_;
			while (TRUE) {
				GeeIterator* _tmp14_ = NULL;
				gboolean _tmp15_ = FALSE;
				EntitasEntity* e = NULL;
				GeeIterator* _tmp16_ = NULL;
				gpointer _tmp17_ = NULL;
				EntitasEntity** _tmp18_ = NULL;
				gint _tmp18__length1 = 0;
				gint _tmp19_ = 0;
				EntitasEntity* _tmp20_ = NULL;
				EntitasEntity* _tmp21_ = NULL;
				EntitasEntity* _tmp22_ = NULL;
				_tmp14_ = _e_it;
				_tmp15_ = gee_iterator_next (_tmp14_);
				if (!_tmp15_) {
					break;
				}
				_tmp16_ = _e_it;
				_tmp17_ = gee_iterator_get (_tmp16_);
				e = (EntitasEntity*) _tmp17_;
				_tmp18_ = self->priv->_entitiesCache;
				_tmp18__length1 = self->priv->_entitiesCache_length1;
				_tmp19_ = i;
				i = _tmp19_ + 1;
				_tmp20_ = e;
				_tmp21_ = _g_object_ref0 (_tmp20_);
				_g_object_unref0 (_tmp18_[_tmp19_]);
				_tmp18_[_tmp19_] = _tmp21_;
				_tmp22_ = _tmp18_[_tmp19_];
				_g_object_unref0 (e);
			}
			_g_object_unref0 (_e_it);
		}
	}
	_tmp23_ = self->priv->_entitiesCache;
	_tmp23__length1 = self->priv->_entitiesCache_length1;
	_tmp24_ = (_tmp23_ != NULL) ? _vala_array_dup5 (_tmp23_, _tmp23__length1) : ((gpointer) _tmp23_);
	_tmp24__length1 = _tmp23__length1;
	_tmp25_ = _tmp24_;
	_tmp25__length1 = _tmp24__length1;
	if (result_length1) {
		*result_length1 = _tmp25__length1;
	}
	result = _tmp25_;
	return result;
}


/**
         * Gets an entity singleton.
         * If a group has more than 1 entity, this is an error condition.
         *
         * @returns entitas.Entity
         */
EntitasEntity* entitas_group_getSingleEntity (EntitasGroup* self, GError** error) {
	EntitasEntity* result = NULL;
	EntitasEntity* _tmp0_ = NULL;
	EntitasEntity* _tmp26_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_singleEntityCache;
	if (_tmp0_ == NULL) {
		GeeCollection* values = NULL;
		GeeHashMap* _tmp1_ = NULL;
		GeeCollection* _tmp2_ = NULL;
		GeeCollection* _tmp3_ = NULL;
		gint c = 0;
		GeeCollection* _tmp4_ = NULL;
		gint _tmp5_ = 0;
		gint _tmp6_ = 0;
		gint _tmp7_ = 0;
		_tmp1_ = self->priv->_entities;
		_tmp2_ = gee_abstract_map_get_values ((GeeMap*) _tmp1_);
		_tmp3_ = _tmp2_;
		values = _tmp3_;
		_tmp4_ = values;
		_tmp5_ = gee_collection_get_size (_tmp4_);
		_tmp6_ = _tmp5_;
		c = _tmp6_;
		_tmp7_ = c;
		if (_tmp7_ == 1) {
			{
				GeeIterator* _e_it = NULL;
				GeeHashMap* _tmp8_ = NULL;
				GeeCollection* _tmp9_ = NULL;
				GeeCollection* _tmp10_ = NULL;
				GeeCollection* _tmp11_ = NULL;
				GeeIterator* _tmp12_ = NULL;
				GeeIterator* _tmp13_ = NULL;
				_tmp8_ = self->priv->_entities;
				_tmp9_ = gee_abstract_map_get_values ((GeeMap*) _tmp8_);
				_tmp10_ = _tmp9_;
				_tmp11_ = _tmp10_;
				_tmp12_ = gee_iterable_iterator ((GeeIterable*) _tmp11_);
				_tmp13_ = _tmp12_;
				_g_object_unref0 (_tmp11_);
				_e_it = _tmp13_;
				while (TRUE) {
					GeeIterator* _tmp14_ = NULL;
					gboolean _tmp15_ = FALSE;
					EntitasEntity* e = NULL;
					GeeIterator* _tmp16_ = NULL;
					gpointer _tmp17_ = NULL;
					EntitasEntity* _tmp18_ = NULL;
					EntitasEntity* _tmp19_ = NULL;
					_tmp14_ = _e_it;
					_tmp15_ = gee_iterator_next (_tmp14_);
					if (!_tmp15_) {
						break;
					}
					_tmp16_ = _e_it;
					_tmp17_ = gee_iterator_get (_tmp16_);
					e = (EntitasEntity*) _tmp17_;
					_tmp18_ = e;
					_tmp19_ = _g_object_ref0 (_tmp18_);
					_g_object_unref0 (self->priv->_singleEntityCache);
					self->priv->_singleEntityCache = _tmp19_;
					_g_object_unref0 (e);
				}
				_g_object_unref0 (_e_it);
			}
		} else {
			gint _tmp20_ = 0;
			_tmp20_ = c;
			if (_tmp20_ == 0) {
				result = NULL;
				_g_object_unref0 (values);
				return result;
			} else {
				EntitasIMatcher* _tmp21_ = NULL;
				gchar* _tmp22_ = NULL;
				gchar* _tmp23_ = NULL;
				GError* _tmp24_ = NULL;
				GError* _tmp25_ = NULL;
				_tmp21_ = self->priv->_matcher;
				_tmp22_ = entitas_imatcher_toString (_tmp21_);
				_tmp23_ = _tmp22_;
				_tmp24_ = g_error_new_literal (ENTITAS_ECS_EXCEPTION, ENTITAS_ECS_EXCEPTION_SingleEntity, _tmp23_);
				_tmp25_ = _tmp24_;
				_g_free0 (_tmp23_);
				_inner_error_ = _tmp25_;
				if (_inner_error_->domain == ENTITAS_ECS_EXCEPTION) {
					g_propagate_error (error, _inner_error_);
					_g_object_unref0 (values);
					return NULL;
				} else {
					_g_object_unref0 (values);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
		}
		_g_object_unref0 (values);
	}
	_tmp26_ = self->priv->_singleEntityCache;
	result = _tmp26_;
	return result;
}


/**
         * Create a string representation for this group:
         *
         *    ex: 'Group(Position)'
         *
         * @returns string
         */
static gchar* string_replace (const gchar* self, const gchar* old, const gchar* replacement) {
	gchar* result = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (old != NULL, NULL);
	g_return_val_if_fail (replacement != NULL, NULL);
	{
		GRegex* regex = NULL;
		const gchar* _tmp0_ = NULL;
		gchar* _tmp1_ = NULL;
		gchar* _tmp2_ = NULL;
		GRegex* _tmp3_ = NULL;
		GRegex* _tmp4_ = NULL;
		gchar* _tmp5_ = NULL;
		GRegex* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		gchar* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		_tmp0_ = old;
		_tmp1_ = g_regex_escape_string (_tmp0_, -1);
		_tmp2_ = _tmp1_;
		_tmp3_ = g_regex_new (_tmp2_, 0, 0, &_inner_error_);
		_tmp4_ = _tmp3_;
		_g_free0 (_tmp2_);
		regex = _tmp4_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch1_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp6_ = regex;
		_tmp7_ = replacement;
		_tmp8_ = g_regex_replace_literal (_tmp6_, self, (gssize) -1, 0, _tmp7_, 0, &_inner_error_);
		_tmp5_ = _tmp8_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_regex_unref0 (regex);
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch1_g_regex_error;
			}
			_g_regex_unref0 (regex);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp9_ = _tmp5_;
		_tmp5_ = NULL;
		result = _tmp9_;
		_g_free0 (_tmp5_);
		_g_regex_unref0 (regex);
		return result;
	}
	goto __finally1;
	__catch1_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally1:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
}


static void _vala_array_add3 (gchar*** array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static gchar* _vala_g_strjoinv (const gchar* separator, gchar** str_array, int str_array_length1) {
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	gchar** _tmp3_ = NULL;
	gint _tmp3__length1 = 0;
	_tmp0_ = separator;
	if (_tmp0_ == NULL) {
		separator = "";
	}
	_tmp3_ = str_array;
	_tmp3__length1 = str_array_length1;
	if (_tmp3_ != NULL) {
		_tmp2_ = TRUE;
	} else {
		gchar** _tmp4_ = NULL;
		gint _tmp4__length1 = 0;
		_tmp4_ = str_array;
		_tmp4__length1 = str_array_length1;
		_tmp2_ = _tmp4__length1 > 0;
	}
	if (_tmp2_) {
		_tmp1_ = TRUE;
	} else {
		gboolean _tmp5_ = FALSE;
		gchar** _tmp6_ = NULL;
		gint _tmp6__length1 = 0;
		_tmp6_ = str_array;
		_tmp6__length1 = str_array_length1;
		if (_tmp6__length1 == -1) {
			gchar** _tmp7_ = NULL;
			gint _tmp7__length1 = 0;
			const gchar* _tmp8_ = NULL;
			_tmp7_ = str_array;
			_tmp7__length1 = str_array_length1;
			_tmp8_ = _tmp7_[0];
			_tmp5_ = _tmp8_ != NULL;
		} else {
			_tmp5_ = FALSE;
		}
		_tmp1_ = _tmp5_;
	}
	if (_tmp1_) {
		gint i = 0;
		gsize len = 0UL;
		gint _tmp31_ = 0;
		gint _tmp33_ = 0;
		gint _tmp34_ = 0;
		gsize _tmp35_ = 0UL;
		const gchar* _tmp36_ = NULL;
		gint _tmp37_ = 0;
		gint _tmp38_ = 0;
		gint _tmp39_ = 0;
		const gchar* res = NULL;
		gsize _tmp40_ = 0UL;
		void* _tmp41_ = NULL;
		void* ptr = NULL;
		const gchar* _tmp42_ = NULL;
		gchar** _tmp43_ = NULL;
		gint _tmp43__length1 = 0;
		const gchar* _tmp44_ = NULL;
		void* _tmp45_ = NULL;
		const gchar* _tmp62_ = NULL;
		len = (gsize) 1;
		{
			gboolean _tmp9_ = FALSE;
			i = 0;
			_tmp9_ = TRUE;
			while (TRUE) {
				gboolean _tmp11_ = FALSE;
				gboolean _tmp12_ = FALSE;
				gchar** _tmp13_ = NULL;
				gint _tmp13__length1 = 0;
				gint _tmp21_ = 0;
				gchar** _tmp22_ = NULL;
				gint _tmp22__length1 = 0;
				gint _tmp23_ = 0;
				const gchar* _tmp24_ = NULL;
				gsize _tmp30_ = 0UL;
				if (!_tmp9_) {
					gint _tmp10_ = 0;
					_tmp10_ = i;
					i = _tmp10_ + 1;
				}
				_tmp9_ = FALSE;
				_tmp13_ = str_array;
				_tmp13__length1 = str_array_length1;
				if (_tmp13__length1 != -1) {
					gint _tmp14_ = 0;
					gchar** _tmp15_ = NULL;
					gint _tmp15__length1 = 0;
					_tmp14_ = i;
					_tmp15_ = str_array;
					_tmp15__length1 = str_array_length1;
					_tmp12_ = _tmp14_ < _tmp15__length1;
				} else {
					_tmp12_ = FALSE;
				}
				if (_tmp12_) {
					_tmp11_ = TRUE;
				} else {
					gboolean _tmp16_ = FALSE;
					gchar** _tmp17_ = NULL;
					gint _tmp17__length1 = 0;
					_tmp17_ = str_array;
					_tmp17__length1 = str_array_length1;
					if (_tmp17__length1 == -1) {
						gchar** _tmp18_ = NULL;
						gint _tmp18__length1 = 0;
						gint _tmp19_ = 0;
						const gchar* _tmp20_ = NULL;
						_tmp18_ = str_array;
						_tmp18__length1 = str_array_length1;
						_tmp19_ = i;
						_tmp20_ = _tmp18_[_tmp19_];
						_tmp16_ = _tmp20_ != NULL;
					} else {
						_tmp16_ = FALSE;
					}
					_tmp11_ = _tmp16_;
				}
				if (!_tmp11_) {
					break;
				}
				_tmp22_ = str_array;
				_tmp22__length1 = str_array_length1;
				_tmp23_ = i;
				_tmp24_ = _tmp22_[_tmp23_];
				if (_tmp24_ != NULL) {
					gchar** _tmp25_ = NULL;
					gint _tmp25__length1 = 0;
					gint _tmp26_ = 0;
					const gchar* _tmp27_ = NULL;
					gint _tmp28_ = 0;
					gint _tmp29_ = 0;
					_tmp25_ = str_array;
					_tmp25__length1 = str_array_length1;
					_tmp26_ = i;
					_tmp27_ = _tmp25_[_tmp26_];
					_tmp28_ = strlen ((const gchar*) _tmp27_);
					_tmp29_ = _tmp28_;
					_tmp21_ = _tmp29_;
				} else {
					_tmp21_ = 0;
				}
				_tmp30_ = len;
				len = _tmp30_ + _tmp21_;
			}
		}
		_tmp31_ = i;
		if (_tmp31_ == 0) {
			gchar* _tmp32_ = NULL;
			_tmp32_ = g_strdup ("");
			result = _tmp32_;
			return result;
		}
		_tmp33_ = i;
		str_array_length1 = _tmp33_;
		_tmp34_ = str_array_length1;
		_tmp35_ = len;
		_tmp36_ = separator;
		_tmp37_ = strlen ((const gchar*) _tmp36_);
		_tmp38_ = _tmp37_;
		_tmp39_ = i;
		len = _tmp35_ + (_tmp38_ * (_tmp39_ - 1));
		_tmp40_ = len;
		_tmp41_ = g_malloc (_tmp40_);
		res = _tmp41_;
		_tmp42_ = res;
		_tmp43_ = str_array;
		_tmp43__length1 = str_array_length1;
		_tmp44_ = _tmp43_[0];
		_tmp45_ = g_stpcpy ((void*) _tmp42_, (const gchar*) _tmp44_);
		ptr = _tmp45_;
		{
			gboolean _tmp46_ = FALSE;
			i = 1;
			_tmp46_ = TRUE;
			while (TRUE) {
				gint _tmp48_ = 0;
				gchar** _tmp49_ = NULL;
				gint _tmp49__length1 = 0;
				void* _tmp50_ = NULL;
				const gchar* _tmp51_ = NULL;
				void* _tmp52_ = NULL;
				const gchar* _tmp53_ = NULL;
				gchar** _tmp54_ = NULL;
				gint _tmp54__length1 = 0;
				gint _tmp55_ = 0;
				const gchar* _tmp56_ = NULL;
				void* _tmp60_ = NULL;
				void* _tmp61_ = NULL;
				if (!_tmp46_) {
					gint _tmp47_ = 0;
					_tmp47_ = i;
					i = _tmp47_ + 1;
				}
				_tmp46_ = FALSE;
				_tmp48_ = i;
				_tmp49_ = str_array;
				_tmp49__length1 = str_array_length1;
				if (!(_tmp48_ < _tmp49__length1)) {
					break;
				}
				_tmp50_ = ptr;
				_tmp51_ = separator;
				_tmp52_ = g_stpcpy (_tmp50_, (const gchar*) _tmp51_);
				ptr = _tmp52_;
				_tmp54_ = str_array;
				_tmp54__length1 = str_array_length1;
				_tmp55_ = i;
				_tmp56_ = _tmp54_[_tmp55_];
				if (_tmp56_ != NULL) {
					gchar** _tmp57_ = NULL;
					gint _tmp57__length1 = 0;
					gint _tmp58_ = 0;
					const gchar* _tmp59_ = NULL;
					_tmp57_ = str_array;
					_tmp57__length1 = str_array_length1;
					_tmp58_ = i;
					_tmp59_ = _tmp57_[_tmp58_];
					_tmp53_ = (const gchar*) _tmp59_;
				} else {
					_tmp53_ = "";
				}
				_tmp60_ = ptr;
				_tmp61_ = g_stpcpy (_tmp60_, _tmp53_);
				ptr = _tmp61_;
			}
		}
		_tmp62_ = res;
		res = NULL;
		result = (gchar*) _tmp62_;
		return result;
	} else {
		gchar* _tmp63_ = NULL;
		_tmp63_ = g_strdup ("");
		result = _tmp63_;
		return result;
	}
}


gchar* entitas_group_toString (EntitasGroup* self) {
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp17_ = NULL;
	gchar* _tmp18_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_toStringCache;
	if (_tmp0_ == NULL) {
		gchar** sb = NULL;
		gchar** _tmp1_ = NULL;
		gint sb_length1 = 0;
		gint _sb_size_ = 0;
		EntitasIMatcher* _tmp2_ = NULL;
		gint* _tmp3_ = NULL;
		gint _tmp3__length1 = 0;
		gint* _tmp4_ = NULL;
		gint _tmp4__length1 = 0;
		gchar** _tmp11_ = NULL;
		gint _tmp11__length1 = 0;
		gchar* _tmp12_ = NULL;
		gchar* _tmp13_ = NULL;
		gchar* _tmp14_ = NULL;
		gchar* _tmp15_ = NULL;
		gchar* _tmp16_ = NULL;
		_tmp1_ = g_new0 (gchar*, 0 + 1);
		sb = _tmp1_;
		sb_length1 = 0;
		_sb_size_ = sb_length1;
		_tmp2_ = self->priv->_matcher;
		_tmp3_ = entitas_imatcher_get_indices (_tmp2_, &_tmp3__length1);
		_tmp4_ = _tmp3_;
		_tmp4__length1 = _tmp3__length1;
		{
			gint* index_collection = NULL;
			gint index_collection_length1 = 0;
			gint _index_collection_size_ = 0;
			gint index_it = 0;
			index_collection = _tmp4_;
			index_collection_length1 = _tmp4__length1;
			for (index_it = 0; index_it < _tmp4__length1; index_it = index_it + 1) {
				gint index = 0;
				index = index_collection[index_it];
				{
					gchar** _tmp5_ = NULL;
					gint _tmp5__length1 = 0;
					gchar** _tmp6_ = NULL;
					gint _tmp6__length1 = 0;
					gchar** _tmp7_ = NULL;
					gint _tmp7__length1 = 0;
					gint _tmp8_ = 0;
					const gchar* _tmp9_ = NULL;
					gchar* _tmp10_ = NULL;
					_tmp5_ = sb;
					_tmp5__length1 = sb_length1;
					_tmp6_ = entitas_world_get_components (&_tmp6__length1);
					_tmp7_ = _tmp6_;
					_tmp7__length1 = _tmp6__length1;
					_tmp8_ = index;
					_tmp9_ = _tmp7_[_tmp8_];
					_tmp10_ = string_replace (_tmp9_, "Component", "");
					_vala_array_add3 (&sb, &sb_length1, &_sb_size_, _tmp10_);
				}
			}
		}
		_tmp11_ = sb;
		_tmp11__length1 = sb_length1;
		_tmp12_ = _vala_g_strjoinv (",", _tmp11_, _tmp11__length1);
		_tmp13_ = _tmp12_;
		_tmp14_ = g_strconcat ("Group(", _tmp13_, NULL);
		_tmp15_ = _tmp14_;
		_tmp16_ = g_strconcat (_tmp15_, ")", NULL);
		_g_free0 (self->priv->_toStringCache);
		self->priv->_toStringCache = _tmp16_;
		_g_free0 (_tmp15_);
		_g_free0 (_tmp13_);
		sb = (_vala_array_free (sb, sb_length1, (GDestroyNotify) g_free), NULL);
	}
	_tmp17_ = self->priv->_toStringCache;
	_tmp18_ = g_strdup (_tmp17_);
	result = _tmp18_;
	return result;
}


EntitasGroupChanged* entitas_group_get_onEntityAdded (EntitasGroup* self) {
	EntitasGroupChanged* result;
	EntitasGroupChanged* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_onEntityAdded;
	result = _tmp0_;
	return result;
}


EntitasGroupChanged* entitas_group_get_onEntityRemoved (EntitasGroup* self) {
	EntitasGroupChanged* result;
	EntitasGroupChanged* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_onEntityRemoved;
	result = _tmp0_;
	return result;
}


EntitasGroupUpdated* entitas_group_get_onEntityUpdated (EntitasGroup* self) {
	EntitasGroupUpdated* result;
	EntitasGroupUpdated* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_onEntityUpdated;
	result = _tmp0_;
	return result;
}


gint entitas_group_get_count (EntitasGroup* self) {
	gint result;
	GeeHashMap* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_entities;
	_tmp1_ = gee_abstract_map_get_size ((GeeMap*) _tmp0_);
	_tmp2_ = _tmp1_;
	result = _tmp2_;
	return result;
}


EntitasIMatcher* entitas_group_get_matcher (EntitasGroup* self) {
	EntitasIMatcher* result;
	EntitasIMatcher* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_matcher;
	result = _tmp0_;
	return result;
}


static void entitas_group_class_init (EntitasGroupClass * klass) {
	entitas_group_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (EntitasGroupPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_entitas_group_get_property;
	G_OBJECT_CLASS (klass)->finalize = entitas_group_finalize;
	/**
	         * Subscribe to Entity Addded events
	         * @type entitas.utils.ISignal */
	g_object_class_install_property (G_OBJECT_CLASS (klass), ENTITAS_GROUP_ON_ENTITY_ADDED, g_param_spec_object ("onEntityAdded", "onEntityAdded", "onEntityAdded", ENTITAS_TYPE_GROUP_CHANGED, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	/**
	         * Subscribe to Entity Removed events
	         * @type entitas.utils.ISignal */
	g_object_class_install_property (G_OBJECT_CLASS (klass), ENTITAS_GROUP_ON_ENTITY_REMOVED, g_param_spec_object ("onEntityRemoved", "onEntityRemoved", "onEntityRemoved", ENTITAS_TYPE_GROUP_CHANGED, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	/**
	         * Subscribe to Entity Updated events
	         * @type entitas.utils.ISignal */
	g_object_class_install_property (G_OBJECT_CLASS (klass), ENTITAS_GROUP_ON_ENTITY_UPDATED, g_param_spec_object ("onEntityUpdated", "onEntityUpdated", "onEntityUpdated", ENTITAS_TYPE_GROUP_UPDATED, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	/**
	         * Count the number of entities in this group
	         * @type number
	         * @name entitas.Group#count */
	g_object_class_install_property (G_OBJECT_CLASS (klass), ENTITAS_GROUP_COUNT, g_param_spec_int ("count", "count", "count", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	/**
	         * Get the Matcher for this group
	         * @type entitas.IMatcher
	         * @name entitas.Group#matcher */
	g_object_class_install_property (G_OBJECT_CLASS (klass), ENTITAS_GROUP_MATCHER, g_param_spec_object ("matcher", "matcher", "matcher", ENTITAS_TYPE_IMATCHER, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static void entitas_group_instance_init (EntitasGroup * self) {
	self->priv = ENTITAS_GROUP_GET_PRIVATE (self);
}


static void entitas_group_finalize (GObject* obj) {
	EntitasGroup * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, ENTITAS_TYPE_GROUP, EntitasGroup);
	_g_object_unref0 (self->priv->_onEntityAdded);
	_g_object_unref0 (self->priv->_onEntityRemoved);
	_g_object_unref0 (self->priv->_onEntityUpdated);
	_g_object_unref0 (self->priv->_matcher);
	_g_object_unref0 (self->priv->_entities);
	self->priv->_entitiesCache = (_vala_array_free (self->priv->_entitiesCache, self->priv->_entitiesCache_length1, (GDestroyNotify) g_object_unref), NULL);
	_g_object_unref0 (self->priv->_singleEntityCache);
	_g_free0 (self->priv->_toStringCache);
	G_OBJECT_CLASS (entitas_group_parent_class)->finalize (obj);
}


GType entitas_group_get_type (void) {
	static volatile gsize entitas_group_type_id__volatile = 0;
	if (g_once_init_enter (&entitas_group_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (EntitasGroupClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) entitas_group_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (EntitasGroup), 0, (GInstanceInitFunc) entitas_group_instance_init, NULL };
		GType entitas_group_type_id;
		entitas_group_type_id = g_type_register_static (G_TYPE_OBJECT, "EntitasGroup", &g_define_type_info, 0);
		g_once_init_leave (&entitas_group_type_id__volatile, entitas_group_type_id);
	}
	return entitas_group_type_id__volatile;
}


static void _vala_entitas_group_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	EntitasGroup * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, ENTITAS_TYPE_GROUP, EntitasGroup);
	switch (property_id) {
		case ENTITAS_GROUP_ON_ENTITY_ADDED:
		g_value_set_object (value, entitas_group_get_onEntityAdded (self));
		break;
		case ENTITAS_GROUP_ON_ENTITY_REMOVED:
		g_value_set_object (value, entitas_group_get_onEntityRemoved (self));
		break;
		case ENTITAS_GROUP_ON_ENTITY_UPDATED:
		g_value_set_object (value, entitas_group_get_onEntityUpdated (self));
		break;
		case ENTITAS_GROUP_COUNT:
		g_value_set_int (value, entitas_group_get_count (self));
		break;
		case ENTITAS_GROUP_MATCHER:
		g_value_set_object (value, entitas_group_get_matcher (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



